/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/8ac1fd8b-25a8-4b1d-a1c4-37523bec9b35 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String messenger;
  float sensor_temperature;
  bool heater_one;
  bool heater_two;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <OneWire.h>
#include <DallasTemperature.h>

#define ONE_WIRE_BUS 2

OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensors(&oneWire);


void setup() {
  pinMode(11, OUTPUT);
  pinMode(12, OUTPUT);

  heater_one = false;
  heater_two = false;

  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500); 

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

struct RecipePhase {
  String name;
  float temperature;
  int durationMin;
};

class Recipe {
  protected:
    bool running = false;
  
    short int currentPhaseId = 0;
    bool temperatureReached = false;
    bool timeReached = false;

    long int keepingStartedAtMs = 0;

    struct RecipePhase recipe[6];
    struct RecipePhase currentPhase;
    
    bool reachTemperature(float temperatureGoal){
      if(temperature < temperatureGoal){
        if(temperature < temperatureGoal - 1){
          heater_one = true;
          heater_two = true;
        } else {
          heater_one = true;
          heater_two = false;
        }
        return false;//not reached
      } 
      heater_one = false;
      heater_two = false;
      keepingStartedAtMs = millis();
      return true;//reached
    };
    bool keepTemperature(float temperatureGoal, int durationMin) {
      Serial.print("keepTemperature: ");
      Serial.print("temperatureGoal - ");
      Serial.print(temperatureGoal);
      Serial.print("; durationMin - ");
      Serial.print(durationMin);
      Serial.print("; keepingStartedAtMs - ");
      Serial.print(keepingStartedAtMs);
      Serial.print("; time diff - ");
      Serial.println(millis() - keepingStartedAtMs);
      
      if((millis() - keepingStartedAtMs) / 1000 / 60 >= durationMin){
        return true;
      }

      if(temperature < temperatureGoal){
        heater_one = true;
        heater_two = false;        
      } else {
        heater_one = false;
        heater_two = false;        
      }
      return false;
    };
  public:
    float temperature = sensor_temperature;
    void run(){
      messenger = "Phase " + String(recipe[0].temperature) + "째C, " + String(recipe[0].durationMin) + "min: started";
      ArduinoCloud.update();
      running = true;
    };
    void stop(){
        running = false;
        heater_one = false;
        heater_two = false;        
    };
    void tick() {
      Serial.println("TICK");  
      Serial.print("Current temperature: ");
      Serial.println(temperature);
      
      if(running){
        if(currentPhaseId < sizeof(recipe)/sizeof(*recipe)) {
          currentPhase = recipe[currentPhaseId];
            
          if(temperatureReached) {
            messenger = "Phase " + String(currentPhase.temperature) + "째C, " + String(currentPhase.durationMin) + "min: temperature reached";
            ArduinoCloud.update();
                        
            timeReached = keepTemperature(currentPhase.temperature, currentPhase.durationMin);
          } else {
            temperatureReached = reachTemperature(currentPhase.temperature);
          }
  
          if(timeReached) {
            messenger = "Phase " + String(currentPhase.temperature) + "째C, " + String(currentPhase.durationMin) + "min: duration reached";
            ArduinoCloud.update();
            
            keepingStartedAtMs = 0;
            temperatureReached = false;
            timeReached = false;
            
            currentPhaseId++;
            if(currentPhaseId < sizeof(recipe)/sizeof(*recipe)) {
              messenger = "Phase " + String(recipe[currentPhaseId].temperature) + "째C, " + String(recipe[currentPhaseId].durationMin) + "min: started";
              ArduinoCloud.update();
            }
          }
        } else {
          if(running) {
              messenger = "Done! Cool it down now.";
              ArduinoCloud.update();
              stop();
          }
        }
      } else {
        if(running) {
          stop();
        }
      }
    }
};

class StoutRecipe : public Recipe {
  public:
    StoutRecipe(){
      this->recipe[0] = {"1", 40.0, 45};
      this->recipe[1] = {"2", 50.0, 20};
      this->recipe[2] = {"3", 64.0, 60};
      this->recipe[3] = {"4", 72.0, 10};
      this->recipe[4] = {"5", 72.0, 20};
      this->recipe[5] = {"6", 78.0, 10};
    } 
};

class IpaRecipe : public Recipe {
  public:
    IpaRecipe(){
      this->recipe[0] = {"1", 40.0, 45};
      this->recipe[1] = {"2", 50.0, 20};
      this->recipe[2] = {"3", 63.0, 60};
      this->recipe[3] = {"4", 70.0, 20};
      this->recipe[4] = {"5", 72.0, 20};
      this->recipe[5] = {"6", 78.0, 10};
    } 
};

class WeissbierRecipe : public Recipe {
  public:
    WeissbierRecipe(){
      this->recipe[0] = {"1", 35.0, 15};
      this->recipe[1] = {"2", 47.0, 20};
      this->recipe[2] = {"3", 65.0, 60};
      this->recipe[3] = {"4", 72.0, 30};
      this->recipe[4] = {"5", 78.0, 10};
      this->recipe[5] = {"6", 78.0, 10};
    } 
};

Recipe recipe;

void loop() {
  sensors.requestTemperatures(); // Send the command to get temperatures
  sensor_temperature = sensors.getTempCByIndex(0);
  recipe.temperature = sensor_temperature;

  recipe.tick();

  digitalWrite(11, heater_one);
  digitalWrite(12, heater_two);
  
  ArduinoCloud.update();
  delay(2000);  
}

void onMessengerChange()  {
  Serial.println(messenger);
  
  if(messenger == "stop") {
    messenger = "Brewing has been stopped!";
    ArduinoCloud.update();  
    recipe.stop();
  } else {
    if(messenger == "stout") {
      messenger = "Stout brewing has been started!";
      ArduinoCloud.update();  
      recipe = StoutRecipe{};
      recipe.run();
    } else {
      if(messenger == "ipa") {
        messenger = "IPA brewing has been started!";
        ArduinoCloud.update();  
        recipe = IpaRecipe{};
        recipe.run();
      } else {
        if(messenger == "weissbier") {
          messenger = "Weissbier brewing has been started!";
          ArduinoCloud.update();  
          recipe = WeissbierRecipe{};
          recipe.run();          
        } else {
          messenger = "I can only brew: stout, ipa or weissbier";
          ArduinoCloud.update();  
        }
      }
    }    
  }
}
